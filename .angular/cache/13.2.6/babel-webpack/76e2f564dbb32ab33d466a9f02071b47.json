{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS'); // @dynamic\n\nclass SmoothScrollManager {\n  constructor(_document, _platform, customDefaultOptions) {\n    this._document = _document;\n    this._platform = _platform; // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n    // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n    // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n    // it cancels the ongoing scroll and starts a new one\n\n    this._onGoingScrolls = new Map();\n    this._defaultOptions = Object.assign({\n      duration: 468,\n      easing: {\n        x1: 0.42,\n        y1: 0,\n        x2: 0.58,\n        y2: 1\n      }\n    }, customDefaultOptions);\n  }\n\n  get _w() {\n    return this._document.defaultView;\n  }\n  /**\r\n   * Timing method\r\n   */\n\n\n  get _now() {\n    return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now;\n  }\n  /**\r\n   * changes scroll position inside an element\r\n   */\n\n\n  _scrollElement(el, x, y) {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n  /**\r\n   * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n   */\n\n\n  _getElement(el, parent) {\n    if (typeof el === 'string') {\n      return (parent || this._document).querySelector(el);\n    }\n\n    return coerceElement(el);\n  }\n  /**\r\n   * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n   */\n\n\n  _initSmoothScroll(el) {\n    if (this._onGoingScrolls.has(el)) {\n      this._onGoingScrolls.get(el).next();\n    }\n\n    return this._onGoingScrolls.set(el, new Subject()).get(el);\n  }\n  /**\r\n   * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n   */\n\n\n  _isFinished(context, destroyed, resolve) {\n    if (context.currentX !== context.x || context.currentY !== context.y) {\n      return true;\n    }\n\n    destroyed.next();\n    resolve();\n    return false;\n  }\n  /**\r\n   * Terminates an ongoing smooth scroll\r\n   */\n\n\n  _interrupted(el, destroyed) {\n    return merge(fromEvent(el, 'wheel', {\n      passive: true,\n      capture: true\n    }), fromEvent(el, 'touchmove', {\n      passive: true,\n      capture: true\n    }), destroyed).pipe(take(1));\n  }\n  /**\r\n   * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n   */\n\n\n  _destroy(el, destroyed) {\n    destroyed.complete();\n\n    this._onGoingScrolls.delete(el);\n  }\n  /**\r\n   * A function called recursively that, given a context, steps through scrolling\r\n   */\n\n\n  _step(context) {\n    return new Observable(subscriber => {\n      let elapsed = (this._now() - context.startTime) / context.duration; // avoid elapsed times higher than one\n\n      elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n      const value = context.easing(elapsed);\n      context.currentX = context.startX + (context.x - context.startX) * value;\n      context.currentY = context.startY + (context.y - context.startY) * value;\n\n      this._scrollElement(context.scrollable, context.currentX, context.currentY); // Proceed to the step\n\n\n      animationFrameScheduler.schedule(() => subscriber.next(context));\n    });\n  }\n\n  _applyScrollToOptions(el, options) {\n    if (!options.duration) {\n      this._scrollElement(el, options.left, options.top);\n\n      return Promise.resolve();\n    } // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n\n\n    const destroyed = this._initSmoothScroll(el);\n\n    const context = {\n      scrollable: el,\n      startTime: this._now(),\n      startX: el.scrollLeft,\n      startY: el.scrollTop,\n      x: options.left == null ? el.scrollLeft : ~~options.left,\n      y: options.top == null ? el.scrollTop : ~~options.top,\n      duration: options.duration,\n      easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n    };\n    return new Promise(resolve => {\n      // Scroll each step recursively\n      of(null).pipe(expand(() => this._step(context).pipe(takeWhile(currContext => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\n    });\n  }\n  /**\r\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n   * left and right always refer to the left and right side of the scrolling container irrespective\r\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n   * in an RTL context.\r\n   * @param scrollable element\r\n   * @param customOptions specified the offsets to scroll to.\r\n   */\n\n\n  scrollTo(scrollable, customOptions) {\n    if (isPlatformBrowser(this._platform)) {\n      const el = this._getElement(scrollable);\n\n      const isRtl = getComputedStyle(el).direction === 'rtl';\n      const rtlScrollAxisType = getRtlScrollAxisType();\n      const options = Object.assign(Object.assign(Object.assign({}, this._defaultOptions), customOptions), {\n        // Rewrite start & end offsets as right or left offsets.\n        left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n        right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n      }); // Rewrite the bottom offset as a top offset.\n\n      if (options.bottom != null) {\n        options.top = el.scrollHeight - el.clientHeight - options.bottom;\n      } // Rewrite the right offset as a left offset.\n\n\n      if (isRtl && rtlScrollAxisType !== 0\n      /* NORMAL */\n      ) {\n        if (options.left != null) {\n          options.right = el.scrollWidth - el.clientWidth - options.left;\n        }\n\n        if (rtlScrollAxisType === 2\n        /* INVERTED */\n        ) {\n          options.left = options.right;\n        } else if (rtlScrollAxisType === 1\n        /* NEGATED */\n        ) {\n          options.left = options.right ? -options.right : options.right;\n        }\n      } else {\n        if (options.right != null) {\n          options.left = el.scrollWidth - el.clientWidth - options.right;\n        }\n      }\n\n      return this._applyScrollToOptions(el, options);\n    }\n\n    return Promise.resolve();\n  }\n  /**\r\n   * Scroll to element by reference or selector\r\n   */\n\n\n  scrollToElement(scrollable, target, customOptions = {}) {\n    const scrollableEl = this._getElement(scrollable);\n\n    const targetEl = this._getElement(target, scrollableEl);\n\n    const options = Object.assign(Object.assign({}, customOptions), {\n      left: targetEl.offsetLeft + (customOptions.left || 0),\n      top: targetEl.offsetTop + (customOptions.top || 0)\n    });\n    return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n  }\n\n}\n\nSmoothScrollManager.ɵfac = function SmoothScrollManager_Factory(t) {\n  return new (t || SmoothScrollManager)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n};\n\nSmoothScrollManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SmoothScrollManager,\n  factory: SmoothScrollManager.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SMOOTH_SCROLL_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\nclass SmoothScroll {\n  constructor(element, smoothScroll) {\n    this.element = element;\n    this.smoothScroll = smoothScroll;\n  }\n\n  scrollTo(options) {\n    return this.smoothScroll.scrollTo(this.element, options);\n  }\n\n  scrollToElement(target, options) {\n    return this.smoothScroll.scrollToElement(this.element, target, options);\n  }\n\n}\n\nSmoothScroll.ɵfac = function SmoothScroll_Factory(t) {\n  return new (t || SmoothScroll)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(SmoothScrollManager));\n};\n\nSmoothScroll.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: SmoothScroll,\n  selectors: [[\"\", \"smoothScroll\", \"\"], [\"\", \"smooth-scroll\", \"\"]],\n  exportAs: [\"smoothScroll\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScroll, [{\n    type: Directive,\n    args: [{\n      selector: '[smoothScroll], [smooth-scroll]',\n      exportAs: 'smoothScroll'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: SmoothScrollManager\n    }];\n  }, null);\n})();\n\nclass SmoothScrollModule {}\n\nSmoothScrollModule.ɵfac = function SmoothScrollModule_Factory(t) {\n  return new (t || SmoothScrollModule)();\n};\n\nSmoothScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: SmoothScrollModule\n});\nSmoothScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SmoothScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [SmoothScroll],\n      exports: [SmoothScroll]\n    }]\n  }], null, null);\n})();\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };","map":{"version":3,"sources":["/Users/ianfe/WebstormProjects/CoccoPanel/node_modules/ngx-scrollbar/fesm2015/ngx-scrollbar-smooth-scroll.mjs"],"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","Directive","NgModule","isPlatformBrowser","DOCUMENT","coerceElement","getRtlScrollAxisType","Subject","merge","fromEvent","Observable","animationFrameScheduler","of","take","expand","takeWhile","takeUntil","finalize","BezierEasing","SMOOTH_SCROLL_OPTIONS","SmoothScrollManager","constructor","_document","_platform","customDefaultOptions","_onGoingScrolls","Map","_defaultOptions","Object","assign","duration","easing","x1","y1","x2","y2","_w","defaultView","_now","performance","now","bind","Date","_scrollElement","el","x","y","scrollLeft","scrollTop","_getElement","parent","querySelector","_initSmoothScroll","has","get","next","set","_isFinished","context","destroyed","resolve","currentX","currentY","_interrupted","passive","capture","pipe","_destroy","complete","delete","_step","subscriber","elapsed","startTime","value","startX","startY","scrollable","schedule","_applyScrollToOptions","options","left","top","Promise","currContext","subscribe","scrollTo","customOptions","isRtl","getComputedStyle","direction","rtlScrollAxisType","end","start","right","bottom","scrollHeight","clientHeight","scrollWidth","clientWidth","scrollToElement","target","scrollableEl","targetEl","offsetLeft","offsetTop","ɵfac","ɵprov","type","args","providedIn","Document","decorators","undefined","SmoothScroll","element","smoothScroll","ElementRef","ɵdir","selector","exportAs","SmoothScrollModule","ɵmod","ɵinj","declarations","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Directive, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\n\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\r\nclass SmoothScrollManager {\r\n    constructor(_document, _platform, customDefaultOptions) {\r\n        this._document = _document;\r\n        this._platform = _platform;\r\n        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\r\n        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\r\n        // Purpose: If user called a scroll function again on the same element before the scrolls completes,\r\n        // it cancels the ongoing scroll and starts a new one\r\n        this._onGoingScrolls = new Map();\r\n        this._defaultOptions = Object.assign({ duration: 468, easing: {\r\n                x1: 0.42,\r\n                y1: 0,\r\n                x2: 0.58,\r\n                y2: 1\r\n            } }, customDefaultOptions);\r\n    }\r\n    get _w() {\r\n        return this._document.defaultView;\r\n    }\r\n    /**\r\n     * Timing method\r\n     */\r\n    get _now() {\r\n        return this._w.performance && this._w.performance.now\r\n            ? this._w.performance.now.bind(this._w.performance)\r\n            : Date.now;\r\n    }\r\n    /**\r\n     * changes scroll position inside an element\r\n     */\r\n    _scrollElement(el, x, y) {\r\n        el.scrollLeft = x;\r\n        el.scrollTop = y;\r\n    }\r\n    /**\r\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\r\n     */\r\n    _getElement(el, parent) {\r\n        if (typeof el === 'string') {\r\n            return (parent || this._document).querySelector(el);\r\n        }\r\n        return coerceElement(el);\r\n    }\r\n    /**\r\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\r\n     */\r\n    _initSmoothScroll(el) {\r\n        if (this._onGoingScrolls.has(el)) {\r\n            this._onGoingScrolls.get(el).next();\r\n        }\r\n        return this._onGoingScrolls.set(el, new Subject()).get(el);\r\n    }\r\n    /**\r\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\r\n     */\r\n    _isFinished(context, destroyed, resolve) {\r\n        if (context.currentX !== context.x || context.currentY !== context.y) {\r\n            return true;\r\n        }\r\n        destroyed.next();\r\n        resolve();\r\n        return false;\r\n    }\r\n    /**\r\n     * Terminates an ongoing smooth scroll\r\n     */\r\n    _interrupted(el, destroyed) {\r\n        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));\r\n    }\r\n    /**\r\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\r\n     */\r\n    _destroy(el, destroyed) {\r\n        destroyed.complete();\r\n        this._onGoingScrolls.delete(el);\r\n    }\r\n    /**\r\n     * A function called recursively that, given a context, steps through scrolling\r\n     */\r\n    _step(context) {\r\n        return new Observable((subscriber) => {\r\n            let elapsed = (this._now() - context.startTime) / context.duration;\r\n            // avoid elapsed times higher than one\r\n            elapsed = elapsed > 1 ? 1 : elapsed;\r\n            // apply easing to elapsed time\r\n            const value = context.easing(elapsed);\r\n            context.currentX = context.startX + (context.x - context.startX) * value;\r\n            context.currentY = context.startY + (context.y - context.startY) * value;\r\n            this._scrollElement(context.scrollable, context.currentX, context.currentY);\r\n            // Proceed to the step\r\n            animationFrameScheduler.schedule(() => subscriber.next(context));\r\n        });\r\n    }\r\n    _applyScrollToOptions(el, options) {\r\n        if (!options.duration) {\r\n            this._scrollElement(el, options.left, options.top);\r\n            return Promise.resolve();\r\n        }\r\n        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\r\n        const destroyed = this._initSmoothScroll(el);\r\n        const context = {\r\n            scrollable: el,\r\n            startTime: this._now(),\r\n            startX: el.scrollLeft,\r\n            startY: el.scrollTop,\r\n            x: options.left == null ? el.scrollLeft : ~~options.left,\r\n            y: options.top == null ? el.scrollTop : ~~options.top,\r\n            duration: options.duration,\r\n            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\r\n        };\r\n        return new Promise(resolve => {\r\n            // Scroll each step recursively\r\n            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\r\n        });\r\n    }\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param scrollable element\r\n     * @param customOptions specified the offsets to scroll to.\r\n     */\r\n    scrollTo(scrollable, customOptions) {\r\n        if (isPlatformBrowser(this._platform)) {\r\n            const el = this._getElement(scrollable);\r\n            const isRtl = getComputedStyle(el).direction === 'rtl';\r\n            const rtlScrollAxisType = getRtlScrollAxisType();\r\n            const options = Object.assign(Object.assign(Object.assign({}, this._defaultOptions), customOptions), {\r\n                // Rewrite start & end offsets as right or left offsets.\r\n                left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,\r\n                right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right\r\n            });\r\n            // Rewrite the bottom offset as a top offset.\r\n            if (options.bottom != null) {\r\n                options.top = el.scrollHeight - el.clientHeight - options.bottom;\r\n            }\r\n            // Rewrite the right offset as a left offset.\r\n            if (isRtl && rtlScrollAxisType !== 0 /* NORMAL */) {\r\n                if (options.left != null) {\r\n                    options.right = el.scrollWidth - el.clientWidth - options.left;\r\n                }\r\n                if (rtlScrollAxisType === 2 /* INVERTED */) {\r\n                    options.left = options.right;\r\n                }\r\n                else if (rtlScrollAxisType === 1 /* NEGATED */) {\r\n                    options.left = options.right ? -options.right : options.right;\r\n                }\r\n            }\r\n            else {\r\n                if (options.right != null) {\r\n                    options.left = el.scrollWidth - el.clientWidth - options.right;\r\n                }\r\n            }\r\n            return this._applyScrollToOptions(el, options);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    /**\r\n     * Scroll to element by reference or selector\r\n     */\r\n    scrollToElement(scrollable, target, customOptions = {}) {\r\n        const scrollableEl = this._getElement(scrollable);\r\n        const targetEl = this._getElement(target, scrollableEl);\r\n        const options = Object.assign(Object.assign({}, customOptions), {\r\n            left: targetEl.offsetLeft + (customOptions.left || 0),\r\n            top: targetEl.offsetTop + (customOptions.top || 0)\r\n        });\r\n        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\r\n    }\r\n}\r\nSmoothScrollManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScrollManager, deps: [{ token: DOCUMENT }, { token: PLATFORM_ID }, { token: SMOOTH_SCROLL_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSmoothScrollManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScrollManager, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: Document, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [PLATFORM_ID]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Optional\r\n                    }, {\r\n                        type: Inject,\r\n                        args: [SMOOTH_SCROLL_OPTIONS]\r\n                    }] }];\r\n    } });\n\nclass SmoothScroll {\r\n    constructor(element, smoothScroll) {\r\n        this.element = element;\r\n        this.smoothScroll = smoothScroll;\r\n    }\r\n    scrollTo(options) {\r\n        return this.smoothScroll.scrollTo(this.element, options);\r\n    }\r\n    scrollToElement(target, options) {\r\n        return this.smoothScroll.scrollToElement(this.element, target, options);\r\n    }\r\n}\r\nSmoothScroll.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScroll, deps: [{ token: i0.ElementRef }, { token: SmoothScrollManager }], target: i0.ɵɵFactoryTarget.Directive });\r\nSmoothScroll.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.3\", type: SmoothScroll, selector: \"[smoothScroll], [smooth-scroll]\", exportAs: [\"smoothScroll\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScroll, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[smoothScroll], [smooth-scroll]',\r\n                    exportAs: 'smoothScroll'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SmoothScrollManager }]; } });\n\nclass SmoothScrollModule {\r\n}\r\nSmoothScrollModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScrollModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nSmoothScrollModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScrollModule, declarations: [SmoothScroll], exports: [SmoothScroll] });\r\nSmoothScrollModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScrollModule });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: SmoothScrollModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [SmoothScroll],\r\n                    exports: [SmoothScroll]\r\n                }]\r\n        }] });\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };\n"]},"metadata":{},"sourceType":"module"}